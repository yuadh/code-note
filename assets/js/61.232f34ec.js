(window.webpackJsonp=window.webpackJsonp||[]).push([[61],{374:function(v,_,t){"use strict";t.r(_);var a=t(7),s=Object(a.a)({},(function(){var v=this,_=v._self._c;return _("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[_("h2",{attrs:{id:"基础课程02"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#基础课程02"}},[v._v("#")]),v._v(" 基础课程02")]),v._v(" "),_("h2",{attrs:{id:"继承"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#继承"}},[v._v("#")]),v._v(" 继承")]),v._v(" "),_("div",{staticClass:"language-java line-numbers-mode"},[_("pre",{pre:!0,attrs:{class:"language-java"}},[_("code",[_("span",{pre:!0,attrs:{class:"token keyword"}},[v._v("public")]),v._v(" "),_("span",{pre:!0,attrs:{class:"token keyword"}},[v._v("class")]),v._v(" 子类名 "),_("span",{pre:!0,attrs:{class:"token keyword"}},[v._v("extends")]),v._v(" 父类名 "),_("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v("{")]),v._v(" "),_("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v("}")]),v._v("\n")])]),v._v(" "),_("div",{staticClass:"line-numbers-wrapper"},[_("span",{staticClass:"line-number"},[v._v("1")]),_("br")])]),_("p",[_("img",{attrs:{src:"http://img.yuadh.com/imgs/2022/09/16/1663316474454.png",alt:"1663316474454.png"}})]),v._v(" "),_("p",[v._v("子类中所有的构造方法默认都会访问父类中无参的构造方法")]),v._v(" "),_("ul",[_("li",[_("p",[v._v("因为子类会继承父类中的数据，可能还会使用父类的数据。所以，子类初始化之前，一定要先完成父类数据的初始化")])]),v._v(" "),_("li",[_("p",[v._v("每一个子类构造方法的第一条语句默认都是："),_("strong",[v._v("super()")])])])]),v._v(" "),_("p",[v._v("如果父类中没有无参构造方法，只有带参构造方法，该怎么办呢？")]),v._v(" "),_("ul",[_("li",[_("p",[v._v("① 通过使用super关键字去显示的调用父类的带参构造方法")])]),v._v(" "),_("li",[_("p",[v._v("② 在父类中自己提供一个无参构造方法")])])]),v._v(" "),_("blockquote",[_("p",[v._v("Java中类只支持单继承，不支持多继承")]),v._v(" "),_("p",[v._v("Java中类支持多层继承")])]),v._v(" "),_("h3",{attrs:{id:"方法重写"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#方法重写"}},[v._v("#")]),v._v(" 方法重写")]),v._v(" "),_("p",[v._v("子类中出现了和父类中一模一样的方法声明")]),v._v(" "),_("ul",[_("li",[v._v("当子类需要父类的功能，而功能主体子类有自己特有内容时，可以重写父类中的方法，这样，即沿袭了父类的功能，又定义了子类特有的内容")])]),v._v(" "),_("p",[_("code",[v._v("@Override")])]),v._v(" "),_("h2",{attrs:{id:"权限修饰符"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#权限修饰符"}},[v._v("#")]),v._v(" 权限修饰符")]),v._v(" "),_("p",[_("img",{attrs:{src:"http://img.yuadh.com/imgs/2022/09/16/1663316953440.png",alt:"1663316953440.png"}})]),v._v(" "),_("p",[_("img",{attrs:{src:"http://img.yuadh.com/imgs/2022/09/16/1663317101012.png",alt:"1663317101012.png"}})]),v._v(" "),_("h2",{attrs:{id:"状态修饰符"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#状态修饰符"}},[v._v("#")]),v._v(" 状态修饰符")]),v._v(" "),_("ul",[_("li",[_("code",[v._v("final")]),v._v("   最终态")]),v._v(" "),_("li",[_("code",[v._v("static")]),v._v("  静态")])]),v._v(" "),_("h3",{attrs:{id:"final"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#final"}},[v._v("#")]),v._v(" final")]),v._v(" "),_("ul",[_("li",[_("p",[v._v("修饰方法：表明该方法是最终方法，"),_("strong",[v._v("不能被重写")])])]),v._v(" "),_("li",[_("p",[v._v("修饰变量：表明该变量是常量，"),_("strong",[v._v("不能再次被赋值")])])]),v._v(" "),_("li",[_("p",[v._v("修饰类：表明该类是最终类，"),_("strong",[v._v("不能被继承")])])]),v._v(" "),_("li",[_("p",[v._v("变量是基本类型：final 修饰指的是基本类型的"),_("strong",[v._v("数据值")]),v._v("不能发生改变")])]),v._v(" "),_("li",[_("p",[v._v("变量是引用类型：final 修饰指的是引用类型的"),_("strong",[v._v("地址值")]),v._v("不能发生改变，但是地址里面的内容是可以发生改变的")])])]),v._v(" "),_("h3",{attrs:{id:"static"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#static"}},[v._v("#")]),v._v(" static")]),v._v(" "),_("p",[_("strong",[v._v("static")]),v._v(" 关键字是静态的意思，可以修饰成员方法，成员变量")]),v._v(" "),_("ul",[_("li",[_("p",[v._v("① 被类的所有对象共享，这也是我们判断是否使用静态关键字的条件")])]),v._v(" "),_("li",[_("p",[v._v("② 可以通过类名调用，当然，也可以通过对象名调用，"),_("strong",[v._v("推荐使用类名调用")])])])]),v._v(" "),_("p",[_("strong",[v._v("非静态的成员方法")])]),v._v(" "),_("ul",[_("li",[_("p",[v._v("能访问静态的成员变量")])]),v._v(" "),_("li",[_("p",[v._v("能访问非静态的成员变量")])]),v._v(" "),_("li",[_("p",[v._v("能访问静态的成员方法")])]),v._v(" "),_("li",[_("p",[v._v("能访问非静态的成员方法")])])]),v._v(" "),_("p",[_("strong",[v._v("静态的成员方法")])]),v._v(" "),_("ul",[_("li",[_("p",[v._v("能访问静态的成员变量")])]),v._v(" "),_("li",[_("p",[v._v("能访问静态的成员方法")])])]),v._v(" "),_("p",[_("strong",[v._v("总结成一句话就是：静态成员方法只能访问静态成员")])]),v._v(" "),_("h2",{attrs:{id:"代码块"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#代码块"}},[v._v("#")]),v._v(" 代码块")]),v._v(" "),_("p",[v._v("代码块：在Java中，使用{}括起来的代码被称为代码块。")]),v._v(" "),_("p",[_("strong",[v._v("根据其位置和声明的不同，可以分为：")])]),v._v(" "),_("ul",[_("li",[_("p",[v._v("局部代码块")]),v._v(" "),_("p",[_("strong",[v._v("局部代码块：在方法中出现；")])]),v._v(" "),_("p",[v._v("限定变量生命周期，及早释放，提高内存利用率")])]),v._v(" "),_("li",[_("p",[v._v("构造代码块")]),v._v(" "),_("p",[_("strong",[v._v("构造代码块：在类中方法外出现；")])]),v._v(" "),_("p",[v._v("多个构造方法方法中相同的代码存放到一起，每次调用构造都执行，并且在构造方法前执行")])]),v._v(" "),_("li",[_("p",[v._v("静态代码块")]),v._v(" "),_("p",[_("strong",[v._v("静态代码块：在类中方法外出现，加了static修饰")])]),v._v(" "),_("p",[v._v("在类中方法外出现，并加上static修饰；用于给类进行初始化，在加载的时候就执行，并且值执行一次。")])]),v._v(" "),_("li",[_("p",[v._v("同步代码块")])])]),v._v(" "),_("h2",{attrs:{id:"多态"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#多态"}},[v._v("#")]),v._v(" 多态")]),v._v(" "),_("p",[v._v("多态：指的是同一个对象，在不同时刻表现出来的多种形态")]),v._v(" "),_("p",[_("strong",[v._v("多态的前提和体现")])]),v._v(" "),_("ul",[_("li",[_("p",[v._v("有继承/实现关系")])]),v._v(" "),_("li",[_("p",[v._v("有方法重写")])]),v._v(" "),_("li",[_("p",[v._v("有父类引用指向子类对象")])])]),v._v(" "),_("p",[_("strong",[v._v("向上转型")])]),v._v(" "),_("p",[v._v("从子到父")]),v._v(" "),_("p",[v._v("父类引用指向子类对象")]),v._v(" "),_("p",[_("strong",[v._v("向下转型")])]),v._v(" "),_("p",[v._v("从父到子")]),v._v(" "),_("p",[v._v("父类引用转为子类对象")]),v._v(" "),_("h2",{attrs:{id:"抽象类"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#抽象类"}},[v._v("#")]),v._v(" 抽象类")])])}),[],!1,null,null,null);_.default=s.exports}}]);